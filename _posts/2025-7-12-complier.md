---
layout: post
title: "编译原理"
date:   2025-7-12
tags: [course]
comments: true
author: Puyuan Zhang
mathjax: true
---

# 编译器原理笔记

## 目录
- [编译器原理笔记](#编译器原理笔记)
  - [目录](#目录)
- [1 编译器整体框架](#1-编译器整体框架)
- [2 文法与语言设计](#2-文法与语言设计)
  - [2.1 文法和语言](#21-文法和语言)
    - [2.1.1 文法](#211-文法)
    - [2.1.2 推导和归约](#212-推导和归约)
    - [2.1.3 语言](#213-语言)
    - [2.1.4 文法的Chomsky分类](#214-文法的chomsky分类)
  - [2.2 语法树与二义文法](#22-语法树与二义文法)
    - [2.2.1 语法树与短语句柄](#221-语法树与短语句柄)
    - [2.2.2 二义性](#222-二义性)
- [3 词法分析](#3-词法分析)
  - [3.1 步骤一：非确定有限自动机(NFA)单符化](#31-步骤一非确定有限自动机nfa单符化)
  - [3.2 步骤二：非确定有限自动机(NFA)确定化](#32-步骤二非确定有限自动机nfa确定化)
  - [3.3 步骤三：化简确定有限自动机(DFA)](#33-步骤三化简确定有限自动机dfa)
  - [3.4 词法分析器的实现](#34-词法分析器的实现)
- [4 语法分析](#4-语法分析)
  - [4.1 LL(1)分析](#41-ll1分析)
    - [4.1.1 步骤1：消除左递归与左公因子](#411-步骤1消除左递归与左公因子)
    - [4.1.2 步骤2：计算first和follow集合](#412-步骤2计算first和follow集合)
    - [4.1.3 步骤3：构造LL(1)分析表](#413-步骤3构造ll1分析表)
    - [4.1.4 步骤4：分析程序](#414-步骤4分析程序)
    - [4.1.5 二义文法处理](#415-二义文法处理)
  - [4.2 LR分析法](#42-lr分析法)
    - [4.2.1 LR(0)](#421-lr0)
    - [4.2.2 SLR(1)](#422-slr1)
    - [4.2.3 LR(1)](#423-lr1)
    - [4.2.4 总结](#424-总结)
- [5 语法制导翻译与中间代码生成](#5-语法制导翻译与中间代码生成)
  - [5.1 属性文法基本概念](#51-属性文法基本概念)
  - [5.2 属性计算方法](#52-属性计算方法)
  - [5.2 C语言的语法制导翻译与中间代码生成实现](#52-c语言的语法制导翻译与中间代码生成实现)
- [6 中间代码优化](#6-中间代码优化)
- [7 目标代码生成](#7-目标代码生成)


# 1 编译器整体框架
![alt text](http://puyuanz.github.io/images/complier/image.png)
以C语言源程序`int a=b+c;`为例子，说明编译器的整体过程:
- 词法分析：将句子分成一个个单词符号token，源程序`int a=b+c;`分析为`<int, INTSYM>, <a, IDENT>, <=, AO>, <b, IDENT>, <+, PLUS>, <c, IDENT>, <;, SEMICOLON>`7个token
- 语法分析：根据文法构造语法分析表，然后通过推导(自上而下的LL分析)或者归约(自下而上的LR分析)判断该句子对应的token串是否构成语法上的正确。
- 语义分析与中间代码生成(语法分析制导)：对文法的符号添加属性，同时把文法符号相关的属性和语义规则用花括号\{\}括起来，插入到产生式右部，在推导或归约过程中执行花括号\{\}中的语句，以形成中间代码。例如上述token串在语法分析的过程中生成中间代码`(+, b, c, $1), (=, $1, -, a)`
- 中间代码优化：根据原来的中间代码，划分基本块。对每个基本块，使用删除公共子表达式、删除无用赋值、复写传播、代码外提、强度削弱、合并已知常量、删除归纳变量的技术，采用DAG优化算法，根据生成DAG生成优化后的中间代码。
- 目标代码生成：将中间代码转为目标代码主要涉及寄存器的分配问题，为了让DAG中每个结点先算右子树再算左子树，最后算中间结点以实现左操作数和目的操作数公用一个寄存器，进行结点重排优化，然后对每个变量计算待用信息，根据待用信息和新的结点顺序，依据基本块代码生成算法生成目标代码。

# 2 文法与语言设计
## 2.1 文法和语言
### 2.1.1 文法
一个文法$G$是一个四元式$(V_N,V_T,P,S)$：
- $V_N$是一个非空有限集合，它的每个元素称为非终结符号
- $V_T$是一个非空有限集合，它的每个元素称为终结符号，$V_T\cap V_N=\emptyset$
- P是一个产生式集合，每个产生式的形式是$\alpha \rightarrow \beta$，其中$\alpha \in (V_T\cup V_N)^*V_N(V_T\cup V_N)^\* $,  $\beta \in (V_T\cup V_N)^\*$
- S是一个非终结符号，称为开始符号，其至少在某个产生式左部出现一次

### 2.1.2 推导和归约
记$\alpha_i$为句型，如果$\alpha_1\Rightarrow \alpha_2\Rightarrow ...\Rightarrow\alpha_n$
- 称$\alpha_1$可推导出$\alpha_n$
- 其逆过程称为归约

一个句型到另一个句型的推导过程往往不唯一(二义性)，因此规范：
- 句型的最右推导称为规范推导；
- 型的最左归约称为规范归约

### 2.1.3 语言
如果一个句型只包含终结符号，则称其为一个句子。

文法G所产生句子的全体是一个语言。

### 2.1.4 文法的Chomsky分类
- 0型文法：对文法$G=(V_N, V_T, P, S)$，称$G$为0型文法或短语文法
- 1型文法：对文法$G=(V_N, V_T, P, S)$，产生式形式为$\alpha A \beta \rightarrow \alpha \gamma \beta$，其中$A\in V_N,\alpha \in V^*,\beta \in V^*,\gamma \in V^*$，称$G$为1型文法或者上下文有关文法
- 2型文法：对文法$G=(V_N, V_T, P, S)$，任何产生式$A\rightarrow \beta \in P$，均有$A\in V_N, \beta \in V^*$，称$G$为2型文法或上下文无关文法。
- 3型文法：对文法$G=(V_N, V_T, P, S)$，产生式形式为$A\rightarrow aB$或$A\rightarrow b$其中$A\in V_N, B\in V_N, a\in V_T, b\in V_T\cup \{\epsilon\}$，称$G$为3型文法或正规文法。

## 2.2 语法树与二义文法
### 2.2.1 语法树与短语句柄
语法分析树，简称语法树，用树形图表示一个句型的推导
- 短语：语法树的子树叶节点构成短语
- 直接短语：二层子树叶节点构成直接短语
- 句柄：最左二层子树叶节点构成句柄

### 2.2.2 二义性
- 文法的二义性：对一个文法，一个句型可以有不同种推导过程。避免二义文法的方法：优先级越高的越远离开始符号：例如四则运算文法：$E\rightarrow T|E+T, T\rightarrow F|T*F, F\rightarrow (E)|i$
- 语言的二义性，存在两个不同的文法$G$和$G'$，有$L(G)=L(G')$即该语言存在二义性。
# 3 词法分析
以正规式$(a|b)^*(aa|bb)(a|b)^*$为例进行词法分析
## 3.1 步骤一：非确定有限自动机(NFA)单符化
- 使初态、终态唯一：
![alt text](http://puyuanz.github.io/images/complier/image-1.png)
- 箭弧单符化：
![alt text](http://puyuanz.github.io/images/complier/image-2.png)

正规式$(a|b)^*(aa|bb)(a|b)^*$构造NFA如下：
![alt text](http://puyuanz.github.io/images/complier/image-3.png)
## 3.2 步骤二：非确定有限自动机(NFA)确定化
![alt text](http://puyuanz.github.io/images/complier/image-4.png)
![alt text](http://puyuanz.github.io/images/complier/image-5.png)
![alt text](http://puyuanz.github.io/images/complier/image-6.png)
## 3.3 步骤三：化简确定有限自动机(DFA)
![alt text](http://puyuanz.github.io/images/complier/image-7.png)
![alt text](http://puyuanz.github.io/images/complier/image-8.png)
![alt text](http://puyuanz.github.io/images/complier/image-9.png)
## 3.4 词法分析器的实现
见[1词法分析](http://github.com/puyuanz/)，包含代码以及总结文档
# 4 语法分析
## 4.1 LL(1)分析
### 4.1.1 步骤1：消除左递归与左公因子
- 显式左递归：$P\rightarrow P\alpha|\beta$转换成$P\rightarrow \beta P', P'\rightarrow \alpha P'|\epsilon$
- 隐式左递归：$S\rightarrow Qc|c, Q\rightarrow Rb|b, R\rightarrow Sa|a$，排序为RQS，并规定排序靠后的不能生成排序靠前的，转换为$S\rightarrow Sabc|abc|bc|c$显式左递归，再用显式左递归方法转换成$S\rightarrow abcS'|bcS'|cS', S'\rightarrow abcS'|\epsilon$。注意这里Q和R没有用，它们只用来生成S，所以不用表示
- 左公因子：$P\rightarrow \alpha A_1|\alpha A_2|...|\alpha A_n|\beta_1|\beta_2|...|\beta_n$转换为$P\rightarrow \alpha A|\beta_1|\beta_2|...|\beta_n, A\rightarrow A_1|A_2|...|A_n$

### 4.1.2 步骤2：计算first和follow集合
- first集合(初始化为空)：
  - 1.首先第一遍看所有产生式右侧的第一个字符为终结符的，将该符号加入到左侧非终结符的first集合。
  - 2.然后对于右侧第一个符号位非终结符的将该终结符的first集合加入到左侧符号的first集合中，如果右侧第一个符号位的first集合中含有$\epsilon$，则把第二个字符的first加入左侧符号的first，之后符号的first包含$\epsilon$的同理。
  - 重复操作2直到first集合没有变化。
- follow集合(开始符号初始化为{#}，其他初始化为空)
  - 1.首先对产生式右侧的所有的非终结符，将它们的follow加入后面符号的first集合。
  - 2.然后对产生式右侧最后一个符号为非终结符号的产生式，将最后一个符号的follow添加产生式左侧的follow集合，如果最后一个符号的first为$\epsilon$则倒数第二个符号的follow也要添加产生式左侧的follow集合，若也包含$\epsilon$同理
  - 重复2直到follow集合不再改变。

### 4.1.3 步骤3：构造LL(1)分析表
- 如果产生式右侧不是$\epsilon$，则把产生式左侧对应的first集合的表项写入该产生式
- 如果产生式右侧是$\epsilon$，则把产生式左侧对应的follow集合的表项写入该产生式

### 4.1.4 步骤4：分析程序
- 1.初始文法符号栈为开始符号$S$
- 2.根据输入串顶的符号找对应LL分析表的文法产生式，用产生式右侧替换左侧
- 3.重复2直到文法符号栈与输入串的栈顶元素相等，然后抵消，然后继续2
- 4.最后输入串只剩'#'，文法符号栈也只剩'#'说明语法正确。

### 4.1.5 二义文法处理
看具体语义进行取舍，消除二义文法。

例如文法：$G[S]:S\rightarrow if\text{ } b \text{ }then \text{ }SA|s, A\rightarrow else S|\epsilon$
![alt text](http://puyuanz.github.io/images/complier/image-10.png)
显然这里S可以表示一个if语句也可以是if-else语句，那么A在遇到else是一定是要和最近的S匹配，所以只要有A遇到else就用产生式$A\rightarrow else S$匹配$if\text{ } b \text{ }then \text{ }SA$中的$S$而不是转为$\epsilon$将这个else与$S\rightarrow if\text{ } b \text{ }then \text{ }SA$左侧的S匹配

## 4.2 LR分析法
### 4.2.1 LR(0)
思想：将输入串每处理一步作为一个状态，构造FA
1. 步骤一：拓广文法，添加产生式$S'\rightarrow S$
2. 步骤二：构建LR(0)项目集规范族
   - 初始化$I^{(0)}=Closure(S'\rightarrow S)$
   - 对前面可移进的项目进行移进，例如$I^{(j)}=Go(I^{(i)},\alpha)$，产生新的项目或者移进到旧的项目中
   - 注意移进后包含类似$A\rightarrow \alpha \cdot A'$这种$\cdot$后紧挨着非终结符，要把非终结符展开，放到里面，注意这里可能涉及递归。
   - 直到没有可以移进的项目
3. 步骤三：LR(0)分析表构造：
   - 将状态1的'#'表的位置写入'acc'。
   - 对$I^{(j)}=Go(I^{(i)},\alpha)$，将$Action[i,\alpha]$写入$sj$
   - 对$I^{(j)}=Go(I^{(i)},A)$，将$Goto[i,A]$写入$j$
   - 对所有含有不可移进项的项目，在它的所有Action项写入$rk$，$k$代表该不可移进项代表的文法序号。
4. 步骤四：LR分析程序
   - 1.初始化状态栈为0，符号栈为'#'，输入串后加入'#'
   - 2.根据输入串顶的符号找对应LR分析表的内容
     - sk就移进，把输入串栈顶元素压入符号栈，同时弹出输入串。然后状态栈压入k
     - rk就归约，对应第k条文法产生式，弹出对应右侧符号数量个符号栈，以及对应数量的状态栈，然后符号栈写入产生式左侧符号$A$，状态栈压入Goto[i, A]，i为当前状态栈的栈顶元素。
   - 3.重复2直到输出串只剩'#'，同时状态栈顶元素为1，对应LR分析表的acc

### 4.2.2 SLR(1)
与LR(0)不同的是在构造LR分析表时，rk写入$Action[i, \alpha]$时，需满足$\alpha \in follow(A)$(记第k条产生式左侧非终结符为$A$)

### 4.2.3 LR(1)
对LR(0)项目$A\rightarrow \alpha \cdot \beta$添加了k个搜索符号$a_1,a_2,...,a_k$，构成LR(k)项目$[A\rightarrow \alpha \cdot \beta, a_1,a_2,...,a_k]$。

与LR(0)不同的点在于构建LR(0)项目集规范族：
- 初始化$I^{(0)}=[S'\rightarrow S,\#],[S \rightarrow ...,\#]$
- 移进的项保留搜索符号。
- 但是移进过程中如果遇到类似$[A\rightarrow \alpha \cdot A'B,a_1]$需要扩展时扩展的项的搜索符号应为$first(Ba_1)$，即$[A'\rightarrow...,first(Ba_1)]$

在构造分析表时，rk写入$Action[i,\alpha]$时需满足$\alpha$属于该归约项的搜索符号

如何解决LR(1)二义文法冲突问题(根据具体语义)：
举例：记$I^{(i)}=[A\rightarrow A+A\cdot,+][A\rightarrow A\cdot + A,+]$，则Action[i,+]有rk和sj冲突，这时候不妨假设移进为A+A+i，此时根据四则运算规则，先算前面的加法，所以应该先归约再移进，所以Action[i,+]=rk

### 4.2.4 总结
LR(0)、SLR(1)和LR(1)本质不同在于rk的填充位置，LR(0)将所有Action位置都填充，SLR(1)将follow(A)（A为产生式左侧的非终结符）的位置填充，LR(1)则限制只能在更精确的搜索符上填充。
因此出现冲突的可能性：LR(0)>SLR(1)>LR(1)。
但同时复杂程度有：
LR(0)<SLR(1)<LR(1)

# 5 语法制导翻译与中间代码生成
## 5.1 属性文法基本概念
属性文法是在上下文无关文法的基础上，为每个文法符号$(V_T\cup V_N)$配备若干属性。

对产生式$A\rightarrow \alpha$有一套语义规则：
$$b=f(c_1,c_2,...,c_k)$$
- $b$是$A$的一个综合属性，且$c_1,c_2,...,c_k$是产生式右边文法符号的属性。
- $b$是产生式右边某个文法符号的一个继承属性，且$c_1,c_2,...,c_k$是$A$或产生式右边任何文法符号的属性。

且：
- 终结符只有综合属性，它们由词法分析器提供
- 非终结符可以由继承属性也可以有综合属性，开始符号所有继承属性作为属性计算前的初始值。

自下而上与自上而下：
- 综合属性的自下而上计算（属性由子节点决定）
![alt text](http://puyuanz.github.io/images/complier/image-11.png)
- 继承属性的自上而下计算（属性由兄弟和父节点决定）
![alt text](http://puyuanz.github.io/images/complier/image-12.png)

## 5.2 属性计算方法
- 树遍历的计算方法：
  1. 将开始符号S传给步骤2让后开始执行。
  2. 对传来的非终结符X，每个以A为左部的产生式$X\rightarrow Y_1Y_2...Y_m$首先依次计算$Y_i$的继承属性，同时将$Y_i$传给步骤2并执行。最后计算X所有的综合属性。
  3. 直到没有可以计算的属性就结束
- 一次扫描的处理方法：
  在语法分析的同时，为每个产生式配上一组语义规则，在语法分析执行的同时执行语义规则，完成有关语义分析和中间代码生成工作

区别：
- 树遍历将语义分析和语法分析分开，且复杂度为O(n^2)
- 一次扫描在语法分析的同时完成语义分析与中间代码生成，称为语法制导翻译。

其中一次扫描的语法分析根据属性文法的不同有不同的计算方法：
- S属性文法：只包含综合属性的文法。只能自下而上计算（在归约的过程执行语义规则）例如四则运算翻译如下：
  ![alt text](http://puyuanz.github.io/images/complier/image-13.png)
- L属性文法：对每个产生式$A\rightarrow X_1X_2...X_n$，其语义规则中每个属性或者是综合属性，或者是$X_i$的一个继承属性，且继承属性仅依赖于：
  - 产生式右部$X_i$的左边符号$X_1,X_2,...,X_{i-1}$的属性
  - 产生式左部$A$的继承属性
  
  且产生式右部符号的继承属性必须在这个符号之前的动作中计算出来。综合属性必须在它所引用的所有属性都计算出来以后才能计算(放在右边末尾)
  例如：
  ![alt text](http://puyuanz.github.io/images/complier/image-15.png)

## 5.2 C语言的语法制导翻译与中间代码生成实现
见[2语法制导翻译与中间代码生成实现](http://github/)

# 6 中间代码优化
这里主要为了删除公共子表达式、复写传播、删除无用赋值，代码外提、强度削弱
用特定的DAG优化算法来构造DAG，主要点有：
- 如果存在的有值的结点就在这个结点上直接附上该变量(主要解决公共子表达式问题)
- 最后一些不用的临时变量结点可以删除
- 然后那些没有变量的有父节点的结点通过\$\$1或者\$\$2的形式保存到临时寄存器中。
构造完寄存器，就按照节点顺序生成对应代码。让每个变量都成为它最后应该的值

# 7 目标代码生成
主要是有一套算法，充分的利用x86目标代码中源操作数1和目的操作数共用一个寄存器的特征进行设计。算法要用到生成变量的待用信息来。整体思想是优先让寄存器保存的值是之后最早用到的变量，即如果没有可用寄存器时先替换最晚用的变量所在的寄存器。


这里还有一个DAG目标代码优化问题，这里主要是考虑到x86目标代码中源操作数1和目的操作数共用一个寄存器，所以一个DAG图如果先计算子树右结点，在计算左节点，接着就计算子树根节点，就更能利用寄存器资源，减少寄存器的替换操作。对节点进行重排，这个算法不仔细说了，但是整体思想类似树的遍历中的那种对称版的后序遍历：
```cpp
TreeNode fun(TreeNode * node) {
  fun(node->rightNode);
  fun(node->leftNode);
  output(node);
}
```
可以这么简单理解，但是还是得看具体的算法(这是更加严谨的)，最后期末考试的时候有个题通过这个好像直接看不出来结果。

注意这里画DAG可能会出现左子树出现在空间的右边，要注意那个根节点延申的那个分支到底在根节点的哪边。

目标代码生成代码见[3x86目标代码生成](http)